==**树与二叉树（非线性）**==

![1581920612001](/tmp/1581920612001.png)

以图中的树为例，根节点与叶子节点

1为根节点， 2.3.4为子节点

**树分为两部分**：节点与边组成（节点可以抽象成为集合，边可以抽象成为对应关系）

若1为全集的话， 2.3.4为他的子集。具有完全包含关系的数据结构。

```c
typedef struct Node {
    int data;
    struct Node *next;//struct Node *next[0] 三叉树
} Node *LinkedList;
树的结构定义
```

![1581921021124](/tmp/1581921021124.png)

以此树为例，该树的深度和高度为5。4号节点的深度为2，高度为4。2号节点的度为1，1号节点的度为3。节点的数量等于边数+1。

对于N叉树，有N个指针指向，任何一个N叉树都可以转换成为二叉树，把非确定性问题转换为确定性问题。

==**深度：自上而下**==

==**高度：自下而上**==

二叉树的每个节点度最多为2，度为0的节点比度为2的节点多1.

推导（n1 + n0 + n2 = n1 + 0 + 2n2）-> n2 + 1 = n0

![1581921610024](/tmp/1581921610024.png)

以此树为例，1的左指针指向的2节点称为1的左孩子，右指针指向的3节点称为1的右孩子。

树的遍历

**前序遍历：根 左 右**     124536

**中序遍历：左 根 右**     425136

**后序遍历：左 右 根**     452631

已知前中或者后中，可以还原二叉树。

树的转换（左孩子右兄弟表示法）

![1581920612001](/tmp/1581920612001.png)

以此树为例，转换为二叉树为（十字链表法）

​          ①

​     ②

⑤         ③

​                     ④

​                ⑤

​                         ⑥

完全二叉树（中国版） 当前只存在度为0和度为2的节点，度为1的节点只会少一个右子树。

满二叉树（中国版） 当前只存在度为2和度为0的节点，没有度为1的节点 

完全二叉树的编号为i的子节点左孩子编号为2 * i，右孩子编号为2 * i + 1，可以用连续空间存储（数组）

二叉树的广义表

![1581922651274](/tmp/1581922651274.png)