**稳定排序**

==**插入排序**：==将数组分成已排序区和待排序区，将已排序区后面的一个元素向前插入到待排序区，直到待排序区没有元素为止。

==**冒泡排序**：==将数组分成已排序区和待排序区，从头到尾扫描待排序区，若前面元素比后面元素大，则交换，每一轮都会将待排序区中最大的放到已排序区的开头，直到待排序区没有元素为止。

以此为例

![1582181909140](/tmp/1582181909140.png)

第一轮排序：1 2 4 5 3 6 7 8 9 10

第二轮排序：1 2 4 3 5 6 7 8 9 10

第三轮排序：1 2 3 4 5 6 7 8 9 10

第四轮排序：1 2 3 4 5 6 7 8 9 10

**优化**：当没有元素交换的时候，冒泡排序整体结束。

==**归并排序：**==初始![1582182721179](/tmp/1582182721179.png)

**分治的思想：**![1582184415037](/tmp/1582184415037.png)

两个有序数组一个长度为m，一个为n，合并成为一个长度为m + n的有序数组。操作m + n次，每一层的时间复杂度为logN，总时间复杂度为O(NlogN)。

**不稳定排序**(选择排序，快速排序)

**==选择排序：==**将数组分成已排序区和待排序区，每一轮从待排序区中选择一个最小元素放到已排序区的尾部，直到待排序区中没有元素为止。

![1582193821715](/tmp/1582193821715.png)

时间复杂度O(n * n)以此为例，第一轮排序：1 2 3 9 8 10 6 7 5 4

第二轮排序：1 2 3 4 8 10 6 7 5 9

第三轮排序：1 2 3 4 5 10 6 7 8 9

第三轮排序：1 2 3 4 5 6 10 7 8 9

第四轮排序：1 2 3 4 5 6 7 10 8 9

第四轮排序：1 2 3 4 5 6 7 8 10 9

第五轮排序：1 2 3 4 5 6 7 8 9 10

**==快速排序：==**![1582194304862](/tmp/1582194304862.png)

时间复杂度O(nlogn)以此为例，第一轮排序：2 1 3 4 5 6 8 7 7 5

二分法查找：![1582196028319](/tmp/1582196028319.png)

min是头指针，max是尾指针，mid = (min + max) / 2;

调整：如果arr[mid] < x, min = mid + 1;

如果arr[mid] > x, max = mid - 1;

如果arr[mid] == x,找到结果;

终止条件：min >= max

特殊情况1：

![1582196287946](/tmp/1582196287946.png)

min是头指针，max是尾指针，mid = (min + max) / 2;

调整：如果arr[mid] == 1, min = mid + 1;

如果arr[mid] != 1, max = mid - 1;

如果min == max, 找到结果;

特殊情况2：

![1582196471410](/tmp/1582196471410.png)

min是头指针，max是尾指针，mid = (min + max) / 2;

调整：如果arr[mid] == 1, min = mid + 1;

如果arr[mid] ！= 1, max = mid - 1;

如果min == max,找到结果;

三分查找：

![1582196649313](/tmp/1582196649313.png)

[L, R]是查找范围，m1是[L, R]的1 / 3处，m2是[L, R]的2 / 3处

调整：如果f[m1] < f[m2], L = m1;

如果f[m2] <= f[m1], R = m2;

如果[m1 - m2] < exp,找到结果;